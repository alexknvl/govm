/*
 * govm p2p api
 *
 * govm的分布式节点间交互的api
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package api

import (
	"bytes"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"github.com/gorilla/mux"
	"github.com/lengzhao/govm/conf"
	core "github.com/lengzhao/govm/core"
	"github.com/lengzhao/govm/event"
	"github.com/lengzhao/govm/handler"
	"github.com/lengzhao/govm/messages"
	"github.com/lengzhao/govm/runtime"
	"github.com/lengzhao/govm/wallet"
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	"strconv"
	"time"
)

var inputString chan string

func init() {
	rand.Seed(time.Now().UnixNano())
	inputString = make(chan string, 1)
	go func() {
		for {
			var in string
			fmt.Scanln(&in)
			if in == "" {
				continue
			}
			select {
			case <-inputString:
				// log.Println("drop old input of IdentifyingCode")
				inputString <- in
			case inputString <- in:
			}
		}
	}()
}

// identifying code,before new transaction,user need input it.
func identifyBeforeTransaction(msg ...interface{}) error {
	if !conf.GetConf().IdentifyingCode {
		return nil
	}
	//clean inputString if exist
	select {
	case <-inputString:
		log.Println("clean old inputString")
	default:
	}
	r := rand.Int63()
	str := fmt.Sprintf("%06d", r%1000000)
	if len(msg) > 0 {
		fmt.Println("Identify:", msg)
	}
	fmt.Println("Input Identifying Code:")
	fmt.Println(str)
	var in string
	timeout := time.After(time.Second * 15)
	select {
	case <-timeout:
		fmt.Println("identify:input timeout(15second)")
		return fmt.Errorf("identify:timeout")
	case in = <-inputString:
	}
	if in != str {
		fmt.Printf("error identifying code,hope:%s,get:%s\n", str, in)
		return fmt.Errorf("error indentifying code")
	}
	return nil
}

// Account account
type Account struct {
	Chain   uint64 `json:"chain,omitempty"`
	Address string `json:"address,omitempty"`
	Cost    uint64 `json:"cost,omitempty"`
}

// AccountGet get account of the address on the chain
func AccountGet(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	r.ParseForm()
	chainStr := vars["chain"]
	addrStr := r.Form.Get("address")
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	var addr []byte
	if addrStr == "" && identifyBeforeTransaction("AccountGet") == nil {
		c := conf.GetConf()
		addrStr = hex.EncodeToString(c.WalletAddr)
	}
	addr, err = hex.DecodeString(addrStr)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error address,must hex string"))
		return
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	out := Account{}
	out.Chain = chain
	out.Address = addrStr
	out.Cost = core.GetUserCoin(chain, addr)
	enc := json.NewEncoder(w)
	enc.Encode(out)
}

// TransactionNew new transaction
func TransactionNew(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err, chainStr)
		return
	}
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	key := runtime.GetHash(data)
	msg := new(messages.NewTransaction)
	msg.Chain = chain
	msg.Key = key
	msg.Data = data
	err = event.Send(msg)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}
	w.WriteHeader(http.StatusOK)
}

// TransMoveInfo move info
type TransMoveInfo struct {
	DstChain uint64 `json:"dst_chain,omitempty"`
	Cost     uint64 `json:"cost,omitempty"`
	Energy   uint64 `json:"energy,omitempty"`
	TransKey string `json:"trans_key,omitempty"`
}

// TransactionMovePost move cost to other chain
func TransactionMovePost(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err, chainStr)
		return
	}
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	info := TransMoveInfo{}
	err = json.Unmarshal(data, &info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Unmarshal body of request,", err)
		return
	}
	c := conf.GetConf()
	coin := core.GetUserCoin(chain, c.WalletAddr)
	if coin < info.Cost {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not enough cost.have:%d,hope:%d\n", coin, info.Cost)
		return
	}
	err = identifyBeforeTransaction("Move:", chain, string(data))
	if err != nil {
		w.WriteHeader(http.StatusUnauthorized)
		fmt.Fprintf(w, "identifying code error,%s", err)
		return
	}
	cAddr := core.Address{}
	runtime.Decode(c.WalletAddr, &cAddr)
	trans := core.NewTransaction(chain, cAddr)
	trans.CreateMove(info.DstChain, info.Cost)
	if info.Energy > trans.Energy {
		trans.Energy = info.Energy
	}
	td := trans.GetSignData()
	sign := wallet.Sign(c.PrivateKey, td)
	if len(c.SignPrefix) > 0 {
		s := make([]byte, len(c.SignPrefix))
		copy(s, c.SignPrefix)
		sign = append(s, sign...)
	}
	trans.SetSign(sign)
	td = trans.Output()
	key := trans.Key[:]

	msg := new(messages.NewTransaction)
	msg.Chain = chain
	msg.Key = key
	msg.Data = td
	err = event.Send(msg)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}

	info.Energy = trans.Energy
	info.TransKey = hex.EncodeToString(key)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// TransferInfo transfer info
type TransferInfo struct {
	Peer     string `json:"peer,omitempty"`
	Cost     uint64 `json:"cost,omitempty"`
	Energy   uint64 `json:"energy,omitempty"`
	TransKey string `json:"trans_key,omitempty"`
}

// TransactionTransferPost transfer
func TransactionTransferPost(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err, chainStr)
		return
	}
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	info := TransferInfo{}
	err = json.Unmarshal(data, &info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Unmarshal body of request,", err)
		return
	}
	if info.Cost == 0 {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "error cost value,", info.Cost)
		return
	}
	dst, err := hex.DecodeString(info.Peer)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "error address of peer,", info.Peer, err)
		return
	}
	if len(dst) != wallet.AddressLength {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "error length of peer address,", info.Peer)
		return
	}
	c := conf.GetConf()
	coin := core.GetUserCoin(chain, c.WalletAddr)
	if coin < info.Cost {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not enough cost.have:%d,hope:%d\n", coin, info.Cost)
		return
	}
	err = identifyBeforeTransaction("Transfer:", chain, string(data))
	if err != nil {
		w.WriteHeader(http.StatusUnauthorized)
		fmt.Fprintf(w, "identifying code error,%s", err)
		return
	}
	cAddr := core.Address{}
	dstAddr := core.Address{}
	runtime.Decode(c.WalletAddr, &cAddr)
	runtime.Decode(dst, &dstAddr)
	log.Printf("transfer,from:%x,to:%x,cost:%d\n", cAddr, dstAddr, info.Cost)
	trans := core.NewTransaction(chain, cAddr)
	trans.CreateTransfer(dstAddr, info.Cost)
	if info.Energy > trans.Energy {
		trans.Energy = info.Energy
	}
	td := trans.GetSignData()
	sign := wallet.Sign(c.PrivateKey, td)
	if len(c.SignPrefix) > 0 {
		s := make([]byte, len(c.SignPrefix))
		copy(s, c.SignPrefix)
		sign = append(s, sign...)
	}
	trans.SetSign(sign)
	td = trans.Output()
	key := trans.Key[:]

	msg := new(messages.NewTransaction)
	msg.Chain = chain
	msg.Key = key
	msg.Data = td
	err = event.Send(msg)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}

	info.Energy = trans.Energy
	info.TransKey = hex.EncodeToString(key)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// MinerInfo miner info of get
type MinerInfo struct {
	Index uint64 `json:"index,omitempty"`
	core.Miner
}

// TransactionMinerGet get miner info
func TransactionMinerGet(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	r.ParseForm()
	chainStr := vars["chain"]
	idStr := r.Form.Get("index")
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	id, err := strconv.ParseUint(idStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error index"))
		return
	}

	miner := core.GetMinerInfo(chain, id)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	out := MinerInfo{}
	out.Index = id
	out.Miner = miner
	enc := json.NewEncoder(w)
	enc.Encode(out)
}

// Miner miner info
type Miner struct {
	TagetChain uint64 `json:"taget_chain,omitempty"`
	Index      uint64 `json:"index,omitempty"`
	Cost       uint64 `json:"cost,omitempty"`
	Energy     uint64 `json:"energy,omitempty"`
	TransKey   string `json:"trans_key,omitempty"`
}

// TransactionMinerPost register miner
func TransactionMinerPost(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err, chainStr)
		return
	}
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	info := Miner{}
	err = json.Unmarshal(data, &info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Unmarshal body of request,", err)
		return
	}
	miner := core.GetMinerInfo(chain, info.Index)
	if miner.Cost[core.MinerNum-1] >= info.Cost {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not enough cost,old miner:%x,cost:%d, self:%d\n", miner.Miner[core.MinerNum-1], miner.Cost[core.MinerNum-1], info.Cost)
		return
	}
	c := conf.GetConf()
	coin := core.GetUserCoin(chain, c.WalletAddr)
	if coin < info.Cost {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not enough cost.have:%d,hope:%d\n", coin, info.Cost)
		return
	}
	for i := 0; i < core.MinerNum; i++ {
		if bytes.Compare(c.WalletAddr, miner.Miner[i][:]) == 0 {
			w.WriteHeader(http.StatusBadRequest)
			fmt.Fprintf(w, "you are the miner.chain:%d,index:%d\n", chain, info.Index)
			return
		}
	}
	err = identifyBeforeTransaction("Register miner:", chain, string(data))
	if err != nil {
		w.WriteHeader(http.StatusUnauthorized)
		fmt.Fprintf(w, "identifying code error,%s", err)
		return
	}
	cAddr := core.Address{}
	runtime.Decode(c.WalletAddr, &cAddr)
	trans := core.NewTransaction(chain, cAddr)
	trans.CreateRegisterMiner(info.TagetChain, info.Index, info.Cost)
	if info.Energy > trans.Energy {
		trans.Energy = info.Energy
	}
	td := trans.GetSignData()
	sign := wallet.Sign(c.PrivateKey, td)
	if len(c.SignPrefix) > 0 {
		s := make([]byte, len(c.SignPrefix))
		copy(s, c.SignPrefix)
		sign = append(s, sign...)
	}
	trans.SetSign(sign)
	td = trans.Output()
	key := trans.Key[:]

	msg := new(messages.NewTransaction)
	msg.Chain = chain
	msg.Key = key
	msg.Data = td
	err = event.Send(msg)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}

	info.Energy = trans.Energy
	info.TransKey = hex.EncodeToString(key)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// NewApp new app
type NewApp struct {
	Cost         uint64 `json:"cost,omitempty"`
	Energy       uint64 `json:"energy,omitempty"`
	CodePath     string `json:"code_path,omitempty"`
	IsPrivate    bool   `json:"is_private,omitempty"`
	EnableRun    bool   `json:"enable_run,omitempty"`
	EnableImport bool   `json:"enable_import,omitempty"`
	AppName      string `json:"app_name,omitempty"`
	TransKey     string `json:"trans_key,omitempty"`
}

// TransactionNewAppPost new app
func TransactionNewAppPost(w http.ResponseWriter, r *http.Request) {
	defer func() {
		err := recover()
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			fmt.Fprintln(w, "error code:", err)
		}
	}()
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err, chainStr)
		return
	}
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	info := NewApp{}
	err = json.Unmarshal(data, &info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Unmarshal body of request,", err)
		return
	}
	c := conf.GetConf()
	coin := core.GetUserCoin(chain, c.WalletAddr)
	if coin < info.Cost {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not enough cost.have:%d,hope:%d\n", coin, info.Cost)
		return
	}
	err = identifyBeforeTransaction("New APP:", chain, string(data))
	if err != nil {
		w.WriteHeader(http.StatusUnauthorized)
		fmt.Fprintf(w, "identifying code error,%s", err)
		return
	}
	var flag uint8
	if !info.IsPrivate {
		flag |= core.AppFlagPlublc
		log.Println("1. flag:", flag)
	}
	if info.EnableRun {
		flag |= core.AppFlagRun
		log.Println("2. flag:", flag)
	}
	if info.EnableImport {
		flag |= core.AppFlagImport
		log.Println("3. flag:", flag)
	}
	code, ln := core.CreateAppFromSourceCode(info.CodePath, flag)
	cAddr := core.Address{}
	runtime.Decode(c.WalletAddr, &cAddr)
	trans := core.NewTransaction(chain, cAddr)
	trans.CreateNewApp(code, ln)
	if info.Energy > trans.Energy {
		trans.Energy = info.Energy
	}
	td := trans.GetSignData()
	sign := wallet.Sign(c.PrivateKey, td)
	if len(c.SignPrefix) > 0 {
		s := make([]byte, len(c.SignPrefix))
		copy(s, c.SignPrefix)
		sign = append(s, sign...)
	}
	trans.SetSign(sign)
	td = trans.Output()
	key := trans.Key[:]

	msg := new(messages.NewTransaction)
	msg.Chain = chain
	msg.Key = key
	msg.Data = td
	err = event.Send(msg)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}

	codeHS := runtime.GetHash(code)
	if info.IsPrivate {
		codeHS = runtime.GetHash(append(codeHS, trans.User[:]...))
	}
	info.AppName = hex.EncodeToString(codeHS)
	info.Energy = trans.Energy
	info.TransKey = hex.EncodeToString(key)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// RunApp run app
type RunApp struct {
	Cost      uint64      `json:"cost,omitempty"`
	Energy    uint64      `json:"energy,omitempty"`
	AppName   string      `json:"app_name,omitempty"`
	Param     string      `json:"param,omitempty"`
	ParamType string      `json:"param_type,omitempty"`
	JSONParam interface{} `json:"json_param,omitempty"`
}

// RespOfNewTrans the response of New Transaction
type RespOfNewTrans struct {
	Chain    uint64 `json:"chain,omitempty"`
	TransKey string `json:"trans_key,omitempty"`
}

// TransactionRunAppPost run app
func TransactionRunAppPost(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err, chainStr)
		return
	}
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	info := RunApp{}
	err = json.Unmarshal(data, &info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Unmarshal body of request,", err)
		return
	}
	log.Println("run app:", info)
	var param []byte
	switch info.ParamType {
	case "json":
		if len(info.Param) > 0 {
			prefix, err := hex.DecodeString(info.Param)
			if err != nil {
				w.WriteHeader(http.StatusBadRequest)
				fmt.Fprintln(w, "error param, hope hex string,", err)
				return
			}
			param = prefix
		}
		jData, _ := json.Marshal(info.JSONParam)
		param = append(param, jData...)
	case "string":
		param = []byte(info.Param)
	default:
		if len(info.Param) > 0 {
			param, err = hex.DecodeString(info.Param)
			if err != nil {
				w.WriteHeader(http.StatusBadRequest)
				fmt.Fprintln(w, "error param, hope hex string,", err)
				return
			}
		}
	}
	app := core.Hash{}
	{
		d, err := hex.DecodeString(info.AppName)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			fmt.Fprintln(w, "error AppName, hope hex string,", err)
			return
		}
		runtime.Decode(d, &app)
	}
	if (app == core.Hash{}) {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "error AppName, fail to decode,", info.AppName)
		return
	}

	c := conf.GetConf()
	coin := core.GetUserCoin(chain, c.WalletAddr)
	if coin < info.Cost {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not enough cost.have:%d,hope:%d\n", coin, info.Cost)
		return
	}

	err = identifyBeforeTransaction("Run APP:", chain, string(data))
	if err != nil {
		w.WriteHeader(http.StatusUnauthorized)
		fmt.Fprintf(w, "identifying code error,%s", err)
		return
	}

	cAddr := core.Address{}
	runtime.Decode(c.WalletAddr, &cAddr)
	trans := core.NewTransaction(chain, cAddr)
	trans.CreateRunApp(app, info.Cost, param)

	if info.Energy > trans.Energy {
		trans.Energy = info.Energy
	}
	td := trans.GetSignData()
	sign := wallet.Sign(c.PrivateKey, td)
	if len(c.SignPrefix) > 0 {
		s := make([]byte, len(c.SignPrefix))
		copy(s, c.SignPrefix)
		sign = append(s, sign...)
	}
	trans.SetSign(sign)
	td = trans.Output()

	msg := new(messages.NewTransaction)
	msg.Chain = chain
	msg.Key = trans.Key[:]
	msg.Data = td
	err = event.Send(msg)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}

	resp := RespOfNewTrans{chain, hex.EncodeToString(trans.Key[:])}
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(resp)
}

// AppLife app life
type AppLife struct {
	Energy   uint64 `json:"energy,omitempty"`
	AppName  string `json:"app_name,omitempty"`
	Life     uint64 `json:"life,omitempty"`
	TransKey string `json:"trans_key,omitempty"`
}

// TransactionAppLifePost update app life
func TransactionAppLifePost(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err, chainStr)
		return
	}
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	info := AppLife{}
	err = json.Unmarshal(data, &info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Unmarshal body of request,", err)
		return
	}
	app := core.Hash{}
	d, err := hex.DecodeString(info.AppName)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "error param, hope hex string,", err)
		return
	}
	runtime.Decode(d, &app)

	c := conf.GetConf()
	coin := core.GetUserCoin(chain, c.WalletAddr)
	if coin < info.Energy {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not enough cost.have:%d,hope:%d\n", coin, info.Energy)
		return
	}
	err = identifyBeforeTransaction("Update APP Life:", chain, string(data))
	if err != nil {
		w.WriteHeader(http.StatusUnauthorized)
		fmt.Fprintf(w, "identifying code error,%s", err)
		return
	}

	cAddr := core.Address{}
	runtime.Decode(c.WalletAddr, &cAddr)
	trans := core.NewTransaction(chain, cAddr)
	trans.CreateUpdateAppLife(app, info.Life)

	if info.Energy > trans.Energy {
		trans.Energy = info.Energy
	}
	td := trans.GetSignData()
	sign := wallet.Sign(c.PrivateKey, td)
	if len(c.SignPrefix) > 0 {
		s := make([]byte, len(c.SignPrefix))
		copy(s, c.SignPrefix)
		sign = append(s, sign...)
	}
	trans.SetSign(sign)
	td = trans.Output()

	msg := new(messages.NewTransaction)
	msg.Chain = chain
	msg.Key = trans.Key[:]
	msg.Data = td
	err = event.Send(msg)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}

	info.Energy = trans.Energy
	info.TransKey = hex.EncodeToString(trans.Key[:])
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// TransactionAppInfoGet get app info
func TransactionAppInfoGet(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	r.ParseForm()
	keyStr := r.Form.Get("key")
	if keyStr == "" {
		keyStr = "e4a05b2b8a4de21d9e6f26e9d7992f7f33e89689f3015f3fc8a3a3278815e28c"
	}
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	var key []byte
	key, err = hex.DecodeString(keyStr)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error key"))
		return
	}
	info := core.GetAppInfoOfChain(chain, key)
	if info == nil {
		w.WriteHeader(http.StatusNotFound)
		w.Write([]byte("error key"))
		fmt.Fprintf(w, "chain:%d,key:%x", chain, key)
		return
	}
	log.Println("app info:", info)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// TransInfo transaction info
type TransInfo struct {
	core.TransactionHead
	Key    []byte
	Size   int
	Others interface{}
}

// TransactionInfoGet get transaction info
func TransactionInfoGet(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	r.ParseForm()
	keyStr := r.Form.Get("key")
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	var key []byte
	key, err = hex.DecodeString(keyStr)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error key"))
		return
	}

	data := core.ReadTransactionData(chain, key)
	if len(data) == 0 {
		w.WriteHeader(http.StatusNotFound)
		w.Write([]byte("error key"))
		fmt.Fprintf(w, "chain:%d,key:%x", chain, key)
		return
	}
	trans := core.DecodeTrans(data)
	if trans == nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error key"))
		return
	}

	info := TransInfo{}
	info.TransactionHead = trans.TransactionHead
	info.Key = key
	si := core.DecodeOpsDataOfTrans(info.Ops, trans.Data)
	ti := core.GetTransInfo(chain, key)
	si["BlockID"] = ti.BlockID
	info.Others = si
	info.Size = len(data)

	d, _ := json.Marshal(info.Others)
	log.Println("trans info:", info.Others, string(d))

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// BlockMinePost mine
func BlockMinePost(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	err = identifyBeforeTransaction("Force mine:", chain)
	if err != nil {
		w.WriteHeader(http.StatusUnauthorized)
		fmt.Fprintf(w, "identifying code error,%s", err)
		return
	}
	msg := new(messages.Mine)
	msg.Chain = chain
	err = event.Send(msg)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(msg)
}

type blockInfo struct {
	Time          uint64   `json:"time,omitempty"`
	Previous      string   `json:"previous,omitempty"`
	Parent        string   `json:"parent,omitempty"`
	LeftChild     string   `json:"left_child,omitempty"`
	RightChild    string   `json:"right_child,omitempty"`
	TransListHash string   `json:"trans_list_hash,omitempty"`
	Producer      string   `json:"producer,omitempty"`
	Chain         uint64   `json:"chain,omitempty"`
	Index         uint64   `json:"index,omitempty"`
	Nonce         uint64   `json:"nonce,omitempty"`
	Size          uint32   `json:"size,omitempty"`
	Key           string   `json:"key,omitempty"`
	TransList     []string `json:"trans_list,omitempty"`
}

// BlockInfoGet get block info
func BlockInfoGet(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	r.ParseForm()
	indexStr := r.Form.Get("index")
	keyStr := r.Form.Get("key")
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	var index uint64
	if indexStr != "" {
		index, err = strconv.ParseUint(indexStr, 10, 64)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte("error index"))
			return
		}
	}
	var key []byte
	if keyStr != "" {
		key, err = hex.DecodeString(keyStr)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte("error key"))
			return
		}
	} else {
		key = core.GetTheBlockKey(chain, index)
	}
	data := core.ReadBlockData(chain, key)
	if len(data) == 0 {
		w.WriteHeader(http.StatusNotFound)
		fmt.Fprintf(w, "error key.chain:%d,key:%x,index:%d\n", chain, key, index)
		return
	}
	block := core.DecodeBlock(data)
	info := blockInfo{}
	info.Time = block.Time
	info.Previous = hex.EncodeToString(block.Previous[:])
	if !block.Parent.Empty() {
		info.Parent = hex.EncodeToString(block.Parent[:])
	}
	if !block.LeftChild.Empty() {
		info.LeftChild = hex.EncodeToString(block.LeftChild[:])
	}
	if !block.RightChild.Empty() {
		info.RightChild = hex.EncodeToString(block.RightChild[:])
	}
	if !block.TransListHash.Empty() {
		info.TransListHash = hex.EncodeToString(block.TransListHash[:])
	}
	info.Producer = hex.EncodeToString(block.Producer[:])
	info.Chain = block.Chain
	info.Index = block.Index
	info.Nonce = block.Nonce
	info.Size = block.Size
	info.Key = hex.EncodeToString(block.Key[:])
	for _, k := range block.TransList {
		info.TransList = append(info.TransList, hex.EncodeToString(k[:]))
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// BlockRollback rollback
func BlockRollback(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	r.ParseForm()
	indexStr := r.Form.Get("index")
	keyStr := r.Form.Get("key")
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	var index uint64
	if indexStr != "" {
		index, err = strconv.ParseUint(indexStr, 10, 64)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte("error index"))
			return
		}
	} else {
		index = core.GetLastBlockIndex(chain)
	}

	var key []byte
	if keyStr != "" {
		key, err = hex.DecodeString(keyStr)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte("error key"))
			return
		}
	} else {
		key = core.GetTheBlockKey(chain, index)
	}
	err = identifyBeforeTransaction("Force rollback:", chain, indexStr, keyStr)
	if err != nil {
		w.WriteHeader(http.StatusUnauthorized)
		fmt.Fprintf(w, "identifying code error,%s", err)
		return
	}

	msg := new(messages.Rollback)
	msg.Chain = chain
	msg.Key = key
	msg.Index = index
	err = event.Send(msg)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}

	w.WriteHeader(http.StatusOK)
}

// ChainNewInfo info of new chain
type ChainNewInfo struct {
	DstChain uint64 `json:"dst_chain,omitempty"`
	Cost     uint64 `json:"cost,omitempty"`
	Energy   uint64 `json:"energy,omitempty"`
	TransKey string `json:"trans_key,omitempty"`
}

// ChainNew new chain
func ChainNew(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err, chainStr)
		return
	}
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	info := ChainNewInfo{}
	err = json.Unmarshal(data, &info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Unmarshal body of request,", err)
		return
	}
	if info.DstChain/2 != chain {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "error dst chain,", info.DstChain)
		return
	}
	c := conf.GetConf()
	coin := core.GetUserCoin(chain, c.WalletAddr)
	if coin < info.Cost {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not enough cost.have:%d,hope:%d\n", coin, info.Cost)
		return
	}
	err = identifyBeforeTransaction("New chain:", chain, string(data))
	if err != nil {
		w.WriteHeader(http.StatusUnauthorized)
		fmt.Fprintf(w, "identifying code error,%s", err)
		return
	}
	cAddr := core.Address{}
	runtime.Decode(c.WalletAddr, &cAddr)
	trans := core.NewTransaction(chain, cAddr)
	trans.CreateNewChain(info.DstChain, info.Cost)
	if info.Energy > trans.Energy {
		trans.Energy = info.Energy
	}
	td := trans.GetSignData()
	sign := wallet.Sign(c.PrivateKey, td)
	if len(c.SignPrefix) > 0 {
		s := make([]byte, len(c.SignPrefix))
		copy(s, c.SignPrefix)
		sign = append(s, sign...)
	}
	trans.SetSign(sign)
	td = trans.Output()
	key := trans.Key[:]

	msg := new(messages.NewTransaction)
	msg.Chain = chain
	msg.Key = key
	msg.Data = td
	err = event.Send(msg)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}

	info.Energy = trans.Energy
	info.TransKey = hex.EncodeToString(key)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// DataInfo data info
type DataInfo struct {
	AppName    string `json:"app_name,omitempty"`
	StructName string `json:"struct_name,omitempty"`
	IsDBData   bool   `json:"is_db_data,omitempty"`
	Key        string `json:"key,omitempty"`
	Value      string `json:"value,omitempty"`
	Life       uint64 `json:"life,omitempty"`
}

// DataGet read data
func DataGet(w http.ResponseWriter, r *http.Request) {
	info := DataInfo{}
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	r.ParseForm()
	info.AppName = r.Form.Get("app_name")
	info.StructName = r.Form.Get("struct_name")
	info.Key = r.Form.Get("key")
	raw := r.Form.Get("raw")
	if r.Form.Get("is_db_data") == "true" {
		info.IsDBData = true
	}

	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}

	key, err := hex.DecodeString(info.Key)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Decode preKey,", info.Key, err)
		return
	}
	val, life := runtime.GetValue(chain, info.IsDBData, info.AppName, info.StructName, key)
	if raw == "true" {
		w.WriteHeader(http.StatusOK)
		w.Write(val)
		return
	}
	info.Value = hex.EncodeToString(val)
	info.Life = life

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// DataPost post data
func DataPost(w http.ResponseWriter, r *http.Request) {
	info := new(messages.RawData)
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	r.ParseForm()
	keyStr := r.Form.Get("key")
	isTrans := r.Form.Get("is_trans")
	broadcast := r.Form.Get("broadcast")
	lockNum := r.Form.Get("lock_num")

	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err, chainStr)
		return
	}
	key, err := hex.DecodeString(keyStr)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Decode preKey,", keyStr, err)
		return
	}
	if lockNum != "" {
		num, err := strconv.ParseUint(lockNum, 10, 64)
		if err == nil {
			info.LockNum = num
		}
	}

	info.Chain = chain
	info.Key = key
	info.Data = data
	if isTrans == "true" {
		info.IsTrans = true
	}
	if broadcast == "true" {
		info.Broadcast = true
	}
	err = event.Send(info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}

	w.WriteHeader(http.StatusOK)
}

// DataNextKey the next key of data
type DataNextKey struct {
	AppName    string `json:"app_name,omitempty"`
	StructName string `json:"struct_name,omitempty"`
	PreKey     string `json:"pre_key,omitempty"`
	IsDBData   bool   `json:"is_db_data,omitempty"`
	Key        string `json:"key,omitempty"`
}

// DataNextKeyGet get next key
func DataNextKeyGet(w http.ResponseWriter, r *http.Request) {
	info := DataNextKey{}
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	r.ParseForm()
	info.AppName = r.Form.Get("app_name")
	info.StructName = r.Form.Get("struct_name")
	info.PreKey = r.Form.Get("pre_key")
	if r.Form.Get("is_db_data") == "true" {
		info.IsDBData = true
	}

	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	var preKey []byte
	if info.PreKey != "" {
		preKey, err = hex.DecodeString(info.PreKey)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			fmt.Fprintln(w, "fail to Decode preKey,", info.PreKey, err)
			return
		}
	}
	key := runtime.GetNextKey(chain, info.IsDBData, info.AppName, info.StructName, preKey)
	info.Key = hex.EncodeToString(key)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// EventInfo event
type EventInfo struct {
	Who   string
	Event string
	Param string
}

// EventPost mine
func EventPost(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err, chainStr)
		return
	}
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	info := EventInfo{}
	err = json.Unmarshal(data, &info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Unmarshal body of request,", err)
		return
	}

	msg := new(messages.ChainEvent)
	msg.Chain = chain
	msg.Who = info.Who
	msg.Event = info.Event
	msg.Param = info.Param
	err = event.Send(msg)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// NodePost add new node
func NodePost(w http.ResponseWriter, r *http.Request) {
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err)
		return
	}
	info := messages.NewNode{}
	err = json.Unmarshal(data, &info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Unmarshal body of request,", err)
		return
	}

	err = event.Send(&info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "error:%s", err)
		return
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("{}"))
}

// NodesGet get nodes
func NodesGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(handler.Nodes)
}

// HistoryInGet get transaction history of recieve
func HistoryInGet(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	r.ParseForm()
	keyStr := r.Form.Get("key")
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	var key []byte
	if keyStr != "" {
		key, err = hex.DecodeString(keyStr)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte("error key"))
			return
		}
	}
	trans := handler.GetInputTrans(chain, key)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(trans)
}

// HistoryOutGet get transaction history of send
func HistoryOutGet(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	r.ParseForm()
	keyStr := r.Form.Get("key")
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	var key []byte
	if keyStr != "" {
		key, err = hex.DecodeString(keyStr)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte("error key"))
			return
		}
	}
	trans := handler.GetOutputTrans(chain, key)
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(trans)
}

// VersionInfo version info
type VersionInfo struct {
	Version   string
	BuildTime string
	GitHead   string
}

// VersionGet get software version
func VersionGet(w http.ResponseWriter, r *http.Request) {
	info := VersionInfo{conf.Version, conf.BuildTime, conf.GitHead}
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// CryptoInfo crypto info
type CryptoInfo struct {
	Owner   string
	Sign    string
	Message string
	HexMsg  bool
}

// CryptoSign crypto:sign message
func CryptoSign(w http.ResponseWriter, r *http.Request) {
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err)
		return
	}
	info := CryptoInfo{}
	err = json.Unmarshal(data, &info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Unmarshal body of request,", err)
		return
	}
	if info.Message == "" {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not message")
		return
	}
	msg := []byte(info.Message)
	if info.HexMsg {
		msg, err = hex.DecodeString(info.Message)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			fmt.Fprintln(w, "fail to DecodeString message,", err)
			return
		}
	}
	err = identifyBeforeTransaction("Sign:", string(data))
	if err != nil {
		w.WriteHeader(http.StatusUnauthorized)
		fmt.Fprintf(w, "identifying code error,%s", err)
		return
	}
	c := conf.GetConf()
	sign := wallet.Sign(c.PrivateKey, msg)
	info.Owner = hex.EncodeToString(c.WalletAddr)
	info.Sign = hex.EncodeToString(sign)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(info)
}

// CryptoCheck Crypto:check the sign
func CryptoCheck(w http.ResponseWriter, r *http.Request) {
	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to read body of request,", err)
		return
	}
	info := CryptoInfo{}
	err = json.Unmarshal(data, &info)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to Unmarshal body of request,", err)
		return
	}
	if info.Owner == "" {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not owner")
		return
	}
	if info.Message == "" {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not message")
		return
	}
	if info.Sign == "" {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "not sign")
		return
	}
	msg := []byte(info.Message)
	if info.HexMsg {
		msg, err = hex.DecodeString(info.Message)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			fmt.Fprintln(w, "fail to DecodeString message,", err)
			return
		}
	}
	sign, err := hex.DecodeString(info.Sign)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintln(w, "fail to DecodeString sign,", err)
		return
	}

	rst := wallet.Recover([]byte(info.Owner), sign, msg)
	if !rst {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	w.WriteHeader(http.StatusOK)
}

// HashPowerGet get hashpower info
func HashPowerGet(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	chainStr := vars["chain"]
	chain, err := strconv.ParseUint(chainStr, 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("error chain"))
		return
	}
	mainnetHP := handler.GetHashPowerOfBlocks(chain)
	myHP := handler.GetMyHashPower(chain)
	type HP struct {
		NetHP  uint64 `json:"net_hp"`
		NodeHP uint64 `json:"node_hp"`
	}
	out := HP{mainnetHP, myHP}
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.Encode(out)
}
